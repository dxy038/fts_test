This paper presents the fundamental theory and algorithms for identifying the most preferred alternative for a decision maker (DM) having a non-centrist (or extremist) preferential behavior. The DM is requested to respond to a set of questions in the form of paired comparison of alternatives. The approach is different than other methods that consider the centrist preferential behavior.

In this paper, an interactive approach is presented to solve the multiple objective linear programming (MOLP) problem. The DM's underlying preferential function is represented by a quasi-convex value (utility) function, which is to be maximized. The method presented in this paper solves MOLP problems with quasi-convex value (utility) functions by using paired comparison of alternatives in the objective space. From the mathematical point of view, maximizing a quasi-convex (or a convex) function over a convex set is considered a difficult problem to solve, while solutions for quasi-concave (or concave) functions are currently available. We prove that our proposed approach converges to the most preferred alternative.

We demonstrate that the most preferred alternative is an extreme point of the MOLP problem, and we develop an interactive method that guarantees obtaining the global most preferred alternative for the MOLP problem. This method requires only a finite number of pivoting operations using a simplex-based method, and it asks only a limited number of paired comparison questions of alternatives in the objective space. We develop a branch and bound algorithm that extends a tree of solutions at each iteration until the MOLP problem is solved. At each iteration, the decision maker has to identify the most preferred alternatives from a given subset of efficient alternatives that are adjacent extreme points to the current basis. Through the branch and bound algorithm, without asking many questions from the decision maker, all branches of the tree are implicitly enumerated until the most preferred alternative is obtained. An example is provided to show the details of the algorithm. Some computational experiments are also presented
