The testing of LSI chips is expensive and unsatisfactory. On the other hand there are cases (as in space ship computers) where a damaged chip must be localized and replaced. The use of self-checking chips seems to be one of several possible solutions of this problem. The theory of the structure of self-checking logical circuit is covered by literature at least at the fundamental form (see References). However, even when the design principles are supposed to be known, their application to the actual creation of a self-checking circuit of an average complexity is and will remain an art. The reason is quite simple and fundamental: optimization of design criteria (engineering qualifications, performance and physical properties of components of the circuits are entities possessing different physical dimensions &#8212; it is impossible to qualify, for instance, two circuits A, B designed for the same task by comparing their speeds and costs if A is faster than B but B is cheaper than A) will never be objective and independent of the talent or whim of the circuit designer. As an example of the design of a self-checking circuit we present here a binary adder (Full Adder) designed under the following considerations: 1: The adder is composed from gates (AND, 0R, NAND, N0R, &#8230;). 2: Two level design was chosen. 3. Ripple carry addition was accepted as sufficient simplification for the design experiment. 4. Only two classes of fault were considered: Stuck at ONE, Stuck at ZERO. 5. Any single fault in the circuit must be signalized either during the activity of the circuit (clock ON) or during a test fault injection (clock OFF). 6. The number of cases where a multiple fault remains undetected must be extremely low in comparison with all possible cases. To obtain an adder with all those requirements the following design idea is used: The adderÂ´s three bit input (X, Y, C) is transformed into an eight bit signal (S<inf>1</inf>, i = 0, 1, &#8230;, 7) by using ONE- FROM EIGHT CODE. This signal, produced by the first level of the circuit, is then transformed by the second level of the circuit into the desired output signal (Z, G) by using four wires and TWO FROM FOUR CODE. Ten fault signals (Fig. 1) are derived from those two codes and checked at the proper state of the clock.
